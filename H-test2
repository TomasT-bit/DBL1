from neo4j import GraphDatabase
import pandas as pd
from scipy import stats
import scikit_posthocs as sp
import seaborn as sns
import matplotlib.pyplot as plt
import os
from scipy.stats import mannwhitneyu

# 1. Configuration (move to top for easy editing)
CONFIG = {
    "neo4j_uri": "bolt://localhost:7687",
    "neo4j_user": "neo4j",
    "neo4j_password": "password",  # Replace with your actual password
    "neo4j_db": "twitter",
    "export_dir": "results",
    "top_n_categories": 5
}

# Create output directory
os.makedirs(CONFIG['export_dir'], exist_ok=True)

# 2. Data Collection
def fetch_conversation_data():
    """Retrieve conversation data from Neo4j"""
    driver = GraphDatabase.driver(
        CONFIG["neo4j_uri"],
        auth=(CONFIG["neo4j_user"], CONFIG["neo4j_password"])
    )
    
    query = """
    MATCH (c:Conversation)
    WHERE c.top_label IS NOT NULL 
      AND c.start_sentiment IS NOT NULL 
      AND c.end_sentiment IS NOT NULL
    RETURN 
      c.top_label AS top_label,
      toFloat(c.start_sentiment) AS start_sentiment,
      toFloat(c.end_sentiment) AS end_sentiment
    """
    
    with driver.session(database=CONFIG["neo4j_db"]) as session:
        records = session.run(query)
        df = pd.DataFrame([dict(record) for record in records])
    
    driver.close()
    return df

# 3. Data Processing
def prepare_data(df):
    """Clean and prepare data for analysis"""
    df['sentiment_change'] = df['end_sentiment'] - df['start_sentiment']
    df = df.dropna(subset=['sentiment_change', 'top_label'])
    return df

# 4. Analysis Functions
def perform_kruskal_test(df):
    """Run Kruskal-Wallis test and return results"""
    groups = [group['sentiment_change'].values 
             for name, group in df.groupby('top_label')]
    return stats.kruskal(*groups)

def calculate_effect_sizes(df, comparisons):
    """Calculate effect sizes for significant pairs"""
    results = {}
    for cat1, cat2 in comparisons:
        group1 = df[df['top_label'] == cat1]['sentiment_change']
        group2 = df[df['top_label'] == cat2]['sentiment_change']
        u, _ = mannwhitneyu(group1, group2)
        cles = u / (len(group1) * len(group2))
        results[f"{cat1} vs {cat2}"] = {
            'cles': cles,
            'magnitude': 'Large' if abs(cles-0.5) > 0.3 else 'Moderate'
        }
    return results

# 5. Visualization Functions
def plot_category_comparison(df, categories, filename):
    """Generate comparison boxplot for specified categories"""
    plt.figure(figsize=(12,6))
    sns.boxplot(data=df[df['top_label'].isin(categories)],
               x='top_label', y='sentiment_change',
               order=categories)
    plt.title(f"Sentiment Change: {' vs '.join(categories)}", pad=20)
    plt.xlabel("Complaint Type")
    plt.ylabel("Sentiment Improvement (End - Start)")
    plt.xticks(rotation=20, ha='right')
    plt.tight_layout()
    plt.savefig(os.path.join(CONFIG['export_dir'], filename), dpi=300)
    plt.close()

# Main Analysis Pipeline
def main():
    # Step 1: Data Collection
    df = fetch_conversation_data()
    
    # Step 2: Data Preparation
    df = prepare_data(df)
    
    # Save category counts
    category_counts = df['top_label'].value_counts()
    category_counts.to_csv(os.path.join(CONFIG['export_dir'], 'category_counts.csv'))
    
    # Step 3: Statistical Analysis
    h_stat, p_value = perform_kruskal_test(df)
    
    # Save test results
    with open(os.path.join(CONFIG['export_dir'], 'test_results.txt'), 'w') as f:
        f.write(f"Kruskal-Wallis Results:\nH = {h_stat:.2f}, p = {p_value:.4f}\n")
    
    # Step 4: Post-hoc Analysis if significant
    if p_value < 0.05:
        posthoc = sp.posthoc_dunn(df, 
                                 val_col='sentiment_change',
                                 group_col='top_label', 
                                 p_adjust='bonferroni')
        posthoc.to_csv(os.path.join(CONFIG['export_dir'], 'posthoc_results.csv'))
        
        # Get top comparisons
        top_comparisons = posthoc.stack().sort_values().head(5).index.tolist()
        
        # Calculate effect sizes
        effect_sizes = calculate_effect_sizes(df, top_comparisons)
        
        # Save effect sizes
        pd.DataFrame.from_dict(effect_sizes, orient='index').to_csv(
            os.path.join(CONFIG['export_dir'], 'effect_sizes.csv'))
    
    # Step 5: Visualizations
    # Top N categories by frequency
    top_cats = category_counts.nlargest(CONFIG['top_n_categories']).index.tolist()
    plot_category_comparison(df, top_cats, 'top_categories.png')
    
    # Top 3 significant comparisons
    if p_value < 0.05:
        for i, (cat1, cat2) in enumerate(top_comparisons[:3], 1):
            plot_category_comparison(df, [cat1, cat2], f'top_comparison_{i}.png')

if __name__ == "__main__":
    main()